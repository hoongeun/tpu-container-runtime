// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXECUTABLE_PLATFORMS_DARWINN_H_
#define FLATBUFFERS_GENERATED_EXECUTABLE_PLATFORMS_DARWINN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace platforms {
namespace darwinn {

struct Meta;
struct MetaBuilder;

struct FieldOffset;
struct FieldOffsetBuilder;

struct InstructionBitstream;
struct InstructionBitstreamBuilder;

struct DmaDescriptorHint;
struct DmaDescriptorHintBuilder;

struct InterruptHint;
struct InterruptHintBuilder;

struct InstructionHint;
struct InstructionHintBuilder;

struct FenceHint;
struct FenceHintBuilder;

struct DmaHint;
struct DmaHintBuilder;

struct DmaHints;
struct DmaHintsBuilder;

struct OutputLayout;
struct OutputLayoutBuilder;

struct Range;

struct TensorShape;
struct TensorShapeBuilder;

struct TensorLayout;
struct TensorLayoutBuilder;

struct OutputShapeInfo;
struct OutputShapeInfoBuilder;

struct NumericsConstants;
struct NumericsConstantsBuilder;

struct OutputLayer;
struct OutputLayerBuilder;

struct InputLayer;
struct InputLayerBuilder;

struct Layer;
struct LayerBuilder;

struct Executable;
struct ExecutableBuilder;

struct MultiExecutable;
struct MultiExecutableBuilder;

struct SerializedPackage;
struct SerializedPackageBuilder;

struct Package;
struct PackageBuilder;

enum Description : int16_t {
  Description_BASE_ADDRESS_OUTPUT_ACTIVATION = 0,
  Description_BASE_ADDRESS_INPUT_ACTIVATION = 1,
  Description_BASE_ADDRESS_PARAMETER = 2,
  Description_BASE_ADDRESS_SCRATCH = 3,
  Description_MIN = Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
  Description_MAX = Description_BASE_ADDRESS_SCRATCH
};

inline const Description (&EnumValuesDescription())[4] {
  static const Description values[] = {
    Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
    Description_BASE_ADDRESS_INPUT_ACTIVATION,
    Description_BASE_ADDRESS_PARAMETER,
    Description_BASE_ADDRESS_SCRATCH
  };
  return values;
}

inline const char * const *EnumNamesDescription() {
  static const char * const names[5] = {
    "BASE_ADDRESS_OUTPUT_ACTIVATION",
    "BASE_ADDRESS_INPUT_ACTIVATION",
    "BASE_ADDRESS_PARAMETER",
    "BASE_ADDRESS_SCRATCH",
    nullptr
  };
  return names;
}

inline const char *EnumNameDescription(Description e) {
  if (::flatbuffers::IsOutRange(e, Description_BASE_ADDRESS_OUTPUT_ACTIVATION, Description_BASE_ADDRESS_SCRATCH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDescription()[index];
}

enum Position : int16_t {
  Position_LOWER_32BIT = 0,
  Position_UPPER_32BIT = 1,
  Position_MIN = Position_LOWER_32BIT,
  Position_MAX = Position_UPPER_32BIT
};

inline const Position (&EnumValuesPosition())[2] {
  static const Position values[] = {
    Position_LOWER_32BIT,
    Position_UPPER_32BIT
  };
  return values;
}

inline const char * const *EnumNamesPosition() {
  static const char * const names[3] = {
    "LOWER_32BIT",
    "UPPER_32BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePosition(Position e) {
  if (::flatbuffers::IsOutRange(e, Position_LOWER_32BIT, Position_UPPER_32BIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPosition()[index];
}

enum InterruptType : int16_t {
  InterruptType_SCALAR_CORE_INT_0 = 0,
  InterruptType_SCALAR_CORE_INT_1 = 1,
  InterruptType_SCALAR_CORE_INT_2 = 2,
  InterruptType_SCALAR_CORE_INT_3 = 3,
  InterruptType_MIN = InterruptType_SCALAR_CORE_INT_0,
  InterruptType_MAX = InterruptType_SCALAR_CORE_INT_3
};

inline const InterruptType (&EnumValuesInterruptType())[4] {
  static const InterruptType values[] = {
    InterruptType_SCALAR_CORE_INT_0,
    InterruptType_SCALAR_CORE_INT_1,
    InterruptType_SCALAR_CORE_INT_2,
    InterruptType_SCALAR_CORE_INT_3
  };
  return values;
}

inline const char * const *EnumNamesInterruptType() {
  static const char * const names[5] = {
    "SCALAR_CORE_INT_0",
    "SCALAR_CORE_INT_1",
    "SCALAR_CORE_INT_2",
    "SCALAR_CORE_INT_3",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterruptType(InterruptType e) {
  if (::flatbuffers::IsOutRange(e, InterruptType_SCALAR_CORE_INT_0, InterruptType_SCALAR_CORE_INT_3)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterruptType()[index];
}

enum Direction : int16_t {
  Direction_INFEED = 0,
  Direction_OUTFEED = 1,
  Direction_MIN = Direction_INFEED,
  Direction_MAX = Direction_OUTFEED
};

inline const Direction (&EnumValuesDirection())[2] {
  static const Direction values[] = {
    Direction_INFEED,
    Direction_OUTFEED
  };
  return values;
}

inline const char * const *EnumNamesDirection() {
  static const char * const names[3] = {
    "INFEED",
    "OUTFEED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDirection(Direction e) {
  if (::flatbuffers::IsOutRange(e, Direction_INFEED, Direction_OUTFEED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDirection()[index];
}

enum AnyHint : uint8_t {
  AnyHint_NONE = 0,
  AnyHint_DmaDescriptorHint = 1,
  AnyHint_InstructionHint = 2,
  AnyHint_InterruptHint = 3,
  AnyHint_FenceHint = 4,
  AnyHint_MIN = AnyHint_NONE,
  AnyHint_MAX = AnyHint_FenceHint
};

inline const AnyHint (&EnumValuesAnyHint())[5] {
  static const AnyHint values[] = {
    AnyHint_NONE,
    AnyHint_DmaDescriptorHint,
    AnyHint_InstructionHint,
    AnyHint_InterruptHint,
    AnyHint_FenceHint
  };
  return values;
}

inline const char * const *EnumNamesAnyHint() {
  static const char * const names[6] = {
    "NONE",
    "DmaDescriptorHint",
    "InstructionHint",
    "InterruptHint",
    "FenceHint",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyHint(AnyHint e) {
  if (::flatbuffers::IsOutRange(e, AnyHint_NONE, AnyHint_FenceHint)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyHint()[index];
}

template<typename T> struct AnyHintTraits {
  static const AnyHint enum_value = AnyHint_NONE;
};

template<> struct AnyHintTraits<platforms::darwinn::DmaDescriptorHint> {
  static const AnyHint enum_value = AnyHint_DmaDescriptorHint;
};

template<> struct AnyHintTraits<platforms::darwinn::InstructionHint> {
  static const AnyHint enum_value = AnyHint_InstructionHint;
};

template<> struct AnyHintTraits<platforms::darwinn::InterruptHint> {
  static const AnyHint enum_value = AnyHint_InterruptHint;
};

template<> struct AnyHintTraits<platforms::darwinn::FenceHint> {
  static const AnyHint enum_value = AnyHint_FenceHint;
};

bool VerifyAnyHint(::flatbuffers::Verifier &verifier, const void *obj, AnyHint type);
bool VerifyAnyHintVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum DataType : int16_t {
  DataType_FIXED_POINT8 = 0,
  DataType_FIXED_POINT16 = 1,
  DataType_SIGNED_FIXED_POINT32 = 2,
  DataType_BFLOAT = 3,
  DataType_HALF = 4,
  DataType_SINGLE = 5,
  DataType_SIGNED_FIXED_POINT8 = 8,
  DataType_SIGNED_FIXED_POINT16 = 9,
  DataType_MIN = DataType_FIXED_POINT8,
  DataType_MAX = DataType_SIGNED_FIXED_POINT16
};

inline const DataType (&EnumValuesDataType())[8] {
  static const DataType values[] = {
    DataType_FIXED_POINT8,
    DataType_FIXED_POINT16,
    DataType_SIGNED_FIXED_POINT32,
    DataType_BFLOAT,
    DataType_HALF,
    DataType_SINGLE,
    DataType_SIGNED_FIXED_POINT8,
    DataType_SIGNED_FIXED_POINT16
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[11] = {
    "FIXED_POINT8",
    "FIXED_POINT16",
    "SIGNED_FIXED_POINT32",
    "BFLOAT",
    "HALF",
    "SINGLE",
    "",
    "",
    "SIGNED_FIXED_POINT8",
    "SIGNED_FIXED_POINT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (::flatbuffers::IsOutRange(e, DataType_FIXED_POINT8, DataType_SIGNED_FIXED_POINT16)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum AnyLayer : uint8_t {
  AnyLayer_NONE = 0,
  AnyLayer_OutputLayer = 1,
  AnyLayer_InputLayer = 2,
  AnyLayer_MIN = AnyLayer_NONE,
  AnyLayer_MAX = AnyLayer_InputLayer
};

inline const AnyLayer (&EnumValuesAnyLayer())[3] {
  static const AnyLayer values[] = {
    AnyLayer_NONE,
    AnyLayer_OutputLayer,
    AnyLayer_InputLayer
  };
  return values;
}

inline const char * const *EnumNamesAnyLayer() {
  static const char * const names[4] = {
    "NONE",
    "OutputLayer",
    "InputLayer",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyLayer(AnyLayer e) {
  if (::flatbuffers::IsOutRange(e, AnyLayer_NONE, AnyLayer_InputLayer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyLayer()[index];
}

template<typename T> struct AnyLayerTraits {
  static const AnyLayer enum_value = AnyLayer_NONE;
};

template<> struct AnyLayerTraits<platforms::darwinn::OutputLayer> {
  static const AnyLayer enum_value = AnyLayer_OutputLayer;
};

template<> struct AnyLayerTraits<platforms::darwinn::InputLayer> {
  static const AnyLayer enum_value = AnyLayer_InputLayer;
};

bool VerifyAnyLayer(::flatbuffers::Verifier &verifier, const void *obj, AnyLayer type);
bool VerifyAnyLayerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ExecutableType : int16_t {
  ExecutableType_STAND_ALONE = 0,
  ExecutableType_PARAMETER_CACHING = 1,
  ExecutableType_EXECUTION_ONLY = 2,
  ExecutableType_MIN = ExecutableType_STAND_ALONE,
  ExecutableType_MAX = ExecutableType_EXECUTION_ONLY
};

inline const ExecutableType (&EnumValuesExecutableType())[3] {
  static const ExecutableType values[] = {
    ExecutableType_STAND_ALONE,
    ExecutableType_PARAMETER_CACHING,
    ExecutableType_EXECUTION_ONLY
  };
  return values;
}

inline const char * const *EnumNamesExecutableType() {
  static const char * const names[4] = {
    "STAND_ALONE",
    "PARAMETER_CACHING",
    "EXECUTION_ONLY",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecutableType(ExecutableType e) {
  if (::flatbuffers::IsOutRange(e, ExecutableType_STAND_ALONE, ExecutableType_EXECUTION_ONLY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutableType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Range FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t start_;
  int32_t end_;

 public:
  Range()
      : start_(0),
        end_(0) {
  }
  Range(int32_t _start, int32_t _end)
      : start_(::flatbuffers::EndianScalar(_start)),
        end_(::flatbuffers::EndianScalar(_end)) {
  }
  int32_t start() const {
    return ::flatbuffers::EndianScalar(start_);
  }
  int32_t end() const {
    return ::flatbuffers::EndianScalar(end_);
  }
};
FLATBUFFERS_STRUCT_END(Range, 8);

struct Meta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESC = 4,
    VT_BATCH = 6,
    VT_NAME = 8,
    VT_POSITION = 10
  };
  platforms::darwinn::Description desc() const {
    return static_cast<platforms::darwinn::Description>(GetField<int16_t>(VT_DESC, 0));
  }
  int32_t batch() const {
    return GetField<int32_t>(VT_BATCH, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  platforms::darwinn::Position position() const {
    return static_cast<platforms::darwinn::Position>(GetField<int16_t>(VT_POSITION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_DESC, 2) &&
           VerifyField<int32_t>(verifier, VT_BATCH, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_POSITION, 2) &&
           verifier.EndTable();
  }
};

struct MetaBuilder {
  typedef Meta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_desc(platforms::darwinn::Description desc) {
    fbb_.AddElement<int16_t>(Meta::VT_DESC, static_cast<int16_t>(desc), 0);
  }
  void add_batch(int32_t batch) {
    fbb_.AddElement<int32_t>(Meta::VT_BATCH, batch, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Meta::VT_NAME, name);
  }
  void add_position(platforms::darwinn::Position position) {
    fbb_.AddElement<int16_t>(Meta::VT_POSITION, static_cast<int16_t>(position), 0);
  }
  explicit MetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Meta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Meta> CreateMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::Description desc = platforms::darwinn::Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
    int32_t batch = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    platforms::darwinn::Position position = platforms::darwinn::Position_LOWER_32BIT) {
  MetaBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_batch(batch);
  builder_.add_position(position);
  builder_.add_desc(desc);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Meta> CreateMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::Description desc = platforms::darwinn::Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
    int32_t batch = 0,
    const char *name = nullptr,
    platforms::darwinn::Position position = platforms::darwinn::Position_LOWER_32BIT) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return platforms::darwinn::CreateMeta(
      _fbb,
      desc,
      batch,
      name__,
      position);
}

struct FieldOffset FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldOffsetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_META = 4,
    VT_OFFSET_BIT = 6
  };
  const platforms::darwinn::Meta *meta() const {
    return GetPointer<const platforms::darwinn::Meta *>(VT_META);
  }
  int32_t offset_bit() const {
    return GetField<int32_t>(VT_OFFSET_BIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyTable(meta()) &&
           VerifyField<int32_t>(verifier, VT_OFFSET_BIT, 4) &&
           verifier.EndTable();
  }
};

struct FieldOffsetBuilder {
  typedef FieldOffset Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_meta(::flatbuffers::Offset<platforms::darwinn::Meta> meta) {
    fbb_.AddOffset(FieldOffset::VT_META, meta);
  }
  void add_offset_bit(int32_t offset_bit) {
    fbb_.AddElement<int32_t>(FieldOffset::VT_OFFSET_BIT, offset_bit, 0);
  }
  explicit FieldOffsetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldOffset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldOffset>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldOffset> CreateFieldOffset(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<platforms::darwinn::Meta> meta = 0,
    int32_t offset_bit = 0) {
  FieldOffsetBuilder builder_(_fbb);
  builder_.add_offset_bit(offset_bit);
  builder_.add_meta(meta);
  return builder_.Finish();
}

struct InstructionBitstream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionBitstreamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITSTREAM = 4,
    VT_FIELD_OFFSETS = 6
  };
  const ::flatbuffers::Vector<uint8_t> *bitstream() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BITSTREAM);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::FieldOffset>> *field_offsets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::FieldOffset>> *>(VT_FIELD_OFFSETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BITSTREAM) &&
           verifier.VerifyVector(bitstream()) &&
           VerifyOffset(verifier, VT_FIELD_OFFSETS) &&
           verifier.VerifyVector(field_offsets()) &&
           verifier.VerifyVectorOfTables(field_offsets()) &&
           verifier.EndTable();
  }
};

struct InstructionBitstreamBuilder {
  typedef InstructionBitstream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bitstream(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bitstream) {
    fbb_.AddOffset(InstructionBitstream::VT_BITSTREAM, bitstream);
  }
  void add_field_offsets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::FieldOffset>>> field_offsets) {
    fbb_.AddOffset(InstructionBitstream::VT_FIELD_OFFSETS, field_offsets);
  }
  explicit InstructionBitstreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstructionBitstream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstructionBitstream>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InstructionBitstream> CreateInstructionBitstream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bitstream = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::FieldOffset>>> field_offsets = 0) {
  InstructionBitstreamBuilder builder_(_fbb);
  builder_.add_field_offsets(field_offsets);
  builder_.add_bitstream(bitstream);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InstructionBitstream> CreateInstructionBitstreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bitstream = nullptr,
    const std::vector<::flatbuffers::Offset<platforms::darwinn::FieldOffset>> *field_offsets = nullptr) {
  auto bitstream__ = bitstream ? _fbb.CreateVector<uint8_t>(*bitstream) : 0;
  auto field_offsets__ = field_offsets ? _fbb.CreateVector<::flatbuffers::Offset<platforms::darwinn::FieldOffset>>(*field_offsets) : 0;
  return platforms::darwinn::CreateInstructionBitstream(
      _fbb,
      bitstream__,
      field_offsets__);
}

struct DmaDescriptorHint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DmaDescriptorHintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_META = 4,
    VT_OFFSET_IN_BYTES = 6,
    VT_SIZE_IN_BYTES = 8
  };
  const platforms::darwinn::Meta *meta() const {
    return GetPointer<const platforms::darwinn::Meta *>(VT_META);
  }
  int32_t offset_in_bytes() const {
    return GetField<int32_t>(VT_OFFSET_IN_BYTES, 0);
  }
  int32_t size_in_bytes() const {
    return GetField<int32_t>(VT_SIZE_IN_BYTES, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyTable(meta()) &&
           VerifyField<int32_t>(verifier, VT_OFFSET_IN_BYTES, 4) &&
           VerifyField<int32_t>(verifier, VT_SIZE_IN_BYTES, 4) &&
           verifier.EndTable();
  }
};

struct DmaDescriptorHintBuilder {
  typedef DmaDescriptorHint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_meta(::flatbuffers::Offset<platforms::darwinn::Meta> meta) {
    fbb_.AddOffset(DmaDescriptorHint::VT_META, meta);
  }
  void add_offset_in_bytes(int32_t offset_in_bytes) {
    fbb_.AddElement<int32_t>(DmaDescriptorHint::VT_OFFSET_IN_BYTES, offset_in_bytes, 0);
  }
  void add_size_in_bytes(int32_t size_in_bytes) {
    fbb_.AddElement<int32_t>(DmaDescriptorHint::VT_SIZE_IN_BYTES, size_in_bytes, 0);
  }
  explicit DmaDescriptorHintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DmaDescriptorHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DmaDescriptorHint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DmaDescriptorHint> CreateDmaDescriptorHint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<platforms::darwinn::Meta> meta = 0,
    int32_t offset_in_bytes = 0,
    int32_t size_in_bytes = 0) {
  DmaDescriptorHintBuilder builder_(_fbb);
  builder_.add_size_in_bytes(size_in_bytes);
  builder_.add_offset_in_bytes(offset_in_bytes);
  builder_.add_meta(meta);
  return builder_.Finish();
}

struct InterruptHint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InterruptHintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  platforms::darwinn::InterruptType type() const {
    return static_cast<platforms::darwinn::InterruptType>(GetField<int16_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE, 2) &&
           verifier.EndTable();
  }
};

struct InterruptHintBuilder {
  typedef InterruptHint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(platforms::darwinn::InterruptType type) {
    fbb_.AddElement<int16_t>(InterruptHint::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  explicit InterruptHintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InterruptHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InterruptHint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InterruptHint> CreateInterruptHint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::InterruptType type = platforms::darwinn::InterruptType_SCALAR_CORE_INT_0) {
  InterruptHintBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct InstructionHint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionHintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUCTION_CHUNK_INDEX = 4
  };
  int32_t instruction_chunk_index() const {
    return GetField<int32_t>(VT_INSTRUCTION_CHUNK_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INSTRUCTION_CHUNK_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct InstructionHintBuilder {
  typedef InstructionHint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instruction_chunk_index(int32_t instruction_chunk_index) {
    fbb_.AddElement<int32_t>(InstructionHint::VT_INSTRUCTION_CHUNK_INDEX, instruction_chunk_index, 0);
  }
  explicit InstructionHintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstructionHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstructionHint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InstructionHint> CreateInstructionHint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t instruction_chunk_index = 0) {
  InstructionHintBuilder builder_(_fbb);
  builder_.add_instruction_chunk_index(instruction_chunk_index);
  return builder_.Finish();
}

struct FenceHint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FenceHintBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FenceHintBuilder {
  typedef FenceHint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FenceHintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FenceHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FenceHint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FenceHint> CreateFenceHint(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FenceHintBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DmaHint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DmaHintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANY_HINT_TYPE = 4,
    VT_ANY_HINT = 6,
    VT_DIRECTION = 8
  };
  platforms::darwinn::AnyHint any_hint_type() const {
    return static_cast<platforms::darwinn::AnyHint>(GetField<uint8_t>(VT_ANY_HINT_TYPE, 0));
  }
  const void *any_hint() const {
    return GetPointer<const void *>(VT_ANY_HINT);
  }
  template<typename T> const T *any_hint_as() const;
  const platforms::darwinn::DmaDescriptorHint *any_hint_as_DmaDescriptorHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_DmaDescriptorHint ? static_cast<const platforms::darwinn::DmaDescriptorHint *>(any_hint()) : nullptr;
  }
  const platforms::darwinn::InstructionHint *any_hint_as_InstructionHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_InstructionHint ? static_cast<const platforms::darwinn::InstructionHint *>(any_hint()) : nullptr;
  }
  const platforms::darwinn::InterruptHint *any_hint_as_InterruptHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_InterruptHint ? static_cast<const platforms::darwinn::InterruptHint *>(any_hint()) : nullptr;
  }
  const platforms::darwinn::FenceHint *any_hint_as_FenceHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_FenceHint ? static_cast<const platforms::darwinn::FenceHint *>(any_hint()) : nullptr;
  }
  platforms::darwinn::Direction direction() const {
    return static_cast<platforms::darwinn::Direction>(GetField<int16_t>(VT_DIRECTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANY_HINT_TYPE, 1) &&
           VerifyOffset(verifier, VT_ANY_HINT) &&
           VerifyAnyHint(verifier, any_hint(), any_hint_type()) &&
           VerifyField<int16_t>(verifier, VT_DIRECTION, 2) &&
           verifier.EndTable();
  }
};

template<> inline const platforms::darwinn::DmaDescriptorHint *DmaHint::any_hint_as<platforms::darwinn::DmaDescriptorHint>() const {
  return any_hint_as_DmaDescriptorHint();
}

template<> inline const platforms::darwinn::InstructionHint *DmaHint::any_hint_as<platforms::darwinn::InstructionHint>() const {
  return any_hint_as_InstructionHint();
}

template<> inline const platforms::darwinn::InterruptHint *DmaHint::any_hint_as<platforms::darwinn::InterruptHint>() const {
  return any_hint_as_InterruptHint();
}

template<> inline const platforms::darwinn::FenceHint *DmaHint::any_hint_as<platforms::darwinn::FenceHint>() const {
  return any_hint_as_FenceHint();
}

struct DmaHintBuilder {
  typedef DmaHint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_any_hint_type(platforms::darwinn::AnyHint any_hint_type) {
    fbb_.AddElement<uint8_t>(DmaHint::VT_ANY_HINT_TYPE, static_cast<uint8_t>(any_hint_type), 0);
  }
  void add_any_hint(::flatbuffers::Offset<void> any_hint) {
    fbb_.AddOffset(DmaHint::VT_ANY_HINT, any_hint);
  }
  void add_direction(platforms::darwinn::Direction direction) {
    fbb_.AddElement<int16_t>(DmaHint::VT_DIRECTION, static_cast<int16_t>(direction), 0);
  }
  explicit DmaHintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DmaHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DmaHint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DmaHint> CreateDmaHint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::AnyHint any_hint_type = platforms::darwinn::AnyHint_NONE,
    ::flatbuffers::Offset<void> any_hint = 0,
    platforms::darwinn::Direction direction = platforms::darwinn::Direction_INFEED) {
  DmaHintBuilder builder_(_fbb);
  builder_.add_any_hint(any_hint);
  builder_.add_direction(direction);
  builder_.add_any_hint_type(any_hint_type);
  return builder_.Finish();
}

struct DmaHints FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DmaHintsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HINTS = 4,
    VT_FULLY_DETERMINISTIC = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::DmaHint>> *hints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::DmaHint>> *>(VT_HINTS);
  }
  bool fully_deterministic() const {
    return GetField<uint8_t>(VT_FULLY_DETERMINISTIC, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HINTS) &&
           verifier.VerifyVector(hints()) &&
           verifier.VerifyVectorOfTables(hints()) &&
           VerifyField<uint8_t>(verifier, VT_FULLY_DETERMINISTIC, 1) &&
           verifier.EndTable();
  }
};

struct DmaHintsBuilder {
  typedef DmaHints Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::DmaHint>>> hints) {
    fbb_.AddOffset(DmaHints::VT_HINTS, hints);
  }
  void add_fully_deterministic(bool fully_deterministic) {
    fbb_.AddElement<uint8_t>(DmaHints::VT_FULLY_DETERMINISTIC, static_cast<uint8_t>(fully_deterministic), 0);
  }
  explicit DmaHintsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DmaHints> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DmaHints>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DmaHints> CreateDmaHints(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::DmaHint>>> hints = 0,
    bool fully_deterministic = false) {
  DmaHintsBuilder builder_(_fbb);
  builder_.add_hints(hints);
  builder_.add_fully_deterministic(fully_deterministic);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DmaHints> CreateDmaHintsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<platforms::darwinn::DmaHint>> *hints = nullptr,
    bool fully_deterministic = false) {
  auto hints__ = hints ? _fbb.CreateVector<::flatbuffers::Offset<platforms::darwinn::DmaHint>>(*hints) : 0;
  return platforms::darwinn::CreateDmaHints(
      _fbb,
      hints__,
      fully_deterministic);
}

struct OutputLayout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OutputLayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP = 4,
    VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP = 6,
    VT_LINEARIZED_TILE_BYTE_OFFSET = 8,
    VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET = 10,
    VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET = 12,
    VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE = 14
  };
  const ::flatbuffers::Vector<int32_t> *y_coordinate_to_linear_tile_id_map() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP);
  }
  const ::flatbuffers::Vector<int32_t> *x_coordinate_to_linear_tile_id_map() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP);
  }
  const ::flatbuffers::Vector<int32_t> *linearized_tile_byte_offset() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_LINEARIZED_TILE_BYTE_OFFSET);
  }
  const ::flatbuffers::Vector<int32_t> *x_coordinate_to_local_byte_offset() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET);
  }
  const ::flatbuffers::Vector<int32_t> *y_coordinate_to_local_y_offset() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET);
  }
  const ::flatbuffers::Vector<int32_t> *x_coordinate_to_local_y_row_size() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP) &&
           verifier.VerifyVector(y_coordinate_to_linear_tile_id_map()) &&
           VerifyOffset(verifier, VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP) &&
           verifier.VerifyVector(x_coordinate_to_linear_tile_id_map()) &&
           VerifyOffset(verifier, VT_LINEARIZED_TILE_BYTE_OFFSET) &&
           verifier.VerifyVector(linearized_tile_byte_offset()) &&
           VerifyOffset(verifier, VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET) &&
           verifier.VerifyVector(x_coordinate_to_local_byte_offset()) &&
           VerifyOffset(verifier, VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET) &&
           verifier.VerifyVector(y_coordinate_to_local_y_offset()) &&
           VerifyOffset(verifier, VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE) &&
           verifier.VerifyVector(x_coordinate_to_local_y_row_size()) &&
           verifier.EndTable();
  }
};

struct OutputLayoutBuilder {
  typedef OutputLayout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_y_coordinate_to_linear_tile_id_map(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> y_coordinate_to_linear_tile_id_map) {
    fbb_.AddOffset(OutputLayout::VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP, y_coordinate_to_linear_tile_id_map);
  }
  void add_x_coordinate_to_linear_tile_id_map(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> x_coordinate_to_linear_tile_id_map) {
    fbb_.AddOffset(OutputLayout::VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP, x_coordinate_to_linear_tile_id_map);
  }
  void add_linearized_tile_byte_offset(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> linearized_tile_byte_offset) {
    fbb_.AddOffset(OutputLayout::VT_LINEARIZED_TILE_BYTE_OFFSET, linearized_tile_byte_offset);
  }
  void add_x_coordinate_to_local_byte_offset(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> x_coordinate_to_local_byte_offset) {
    fbb_.AddOffset(OutputLayout::VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET, x_coordinate_to_local_byte_offset);
  }
  void add_y_coordinate_to_local_y_offset(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> y_coordinate_to_local_y_offset) {
    fbb_.AddOffset(OutputLayout::VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET, y_coordinate_to_local_y_offset);
  }
  void add_x_coordinate_to_local_y_row_size(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> x_coordinate_to_local_y_row_size) {
    fbb_.AddOffset(OutputLayout::VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE, x_coordinate_to_local_y_row_size);
  }
  explicit OutputLayoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OutputLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OutputLayout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OutputLayout> CreateOutputLayout(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> y_coordinate_to_linear_tile_id_map = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> x_coordinate_to_linear_tile_id_map = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> linearized_tile_byte_offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> x_coordinate_to_local_byte_offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> y_coordinate_to_local_y_offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> x_coordinate_to_local_y_row_size = 0) {
  OutputLayoutBuilder builder_(_fbb);
  builder_.add_x_coordinate_to_local_y_row_size(x_coordinate_to_local_y_row_size);
  builder_.add_y_coordinate_to_local_y_offset(y_coordinate_to_local_y_offset);
  builder_.add_x_coordinate_to_local_byte_offset(x_coordinate_to_local_byte_offset);
  builder_.add_linearized_tile_byte_offset(linearized_tile_byte_offset);
  builder_.add_x_coordinate_to_linear_tile_id_map(x_coordinate_to_linear_tile_id_map);
  builder_.add_y_coordinate_to_linear_tile_id_map(y_coordinate_to_linear_tile_id_map);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OutputLayout> CreateOutputLayoutDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *y_coordinate_to_linear_tile_id_map = nullptr,
    const std::vector<int32_t> *x_coordinate_to_linear_tile_id_map = nullptr,
    const std::vector<int32_t> *linearized_tile_byte_offset = nullptr,
    const std::vector<int32_t> *x_coordinate_to_local_byte_offset = nullptr,
    const std::vector<int32_t> *y_coordinate_to_local_y_offset = nullptr,
    const std::vector<int32_t> *x_coordinate_to_local_y_row_size = nullptr) {
  auto y_coordinate_to_linear_tile_id_map__ = y_coordinate_to_linear_tile_id_map ? _fbb.CreateVector<int32_t>(*y_coordinate_to_linear_tile_id_map) : 0;
  auto x_coordinate_to_linear_tile_id_map__ = x_coordinate_to_linear_tile_id_map ? _fbb.CreateVector<int32_t>(*x_coordinate_to_linear_tile_id_map) : 0;
  auto linearized_tile_byte_offset__ = linearized_tile_byte_offset ? _fbb.CreateVector<int32_t>(*linearized_tile_byte_offset) : 0;
  auto x_coordinate_to_local_byte_offset__ = x_coordinate_to_local_byte_offset ? _fbb.CreateVector<int32_t>(*x_coordinate_to_local_byte_offset) : 0;
  auto y_coordinate_to_local_y_offset__ = y_coordinate_to_local_y_offset ? _fbb.CreateVector<int32_t>(*y_coordinate_to_local_y_offset) : 0;
  auto x_coordinate_to_local_y_row_size__ = x_coordinate_to_local_y_row_size ? _fbb.CreateVector<int32_t>(*x_coordinate_to_local_y_row_size) : 0;
  return platforms::darwinn::CreateOutputLayout(
      _fbb,
      y_coordinate_to_linear_tile_id_map__,
      x_coordinate_to_linear_tile_id_map__,
      linearized_tile_byte_offset__,
      x_coordinate_to_local_byte_offset__,
      y_coordinate_to_local_y_offset__,
      x_coordinate_to_local_y_row_size__);
}

struct TensorShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMENSION = 4
  };
  const ::flatbuffers::Vector<const platforms::darwinn::Range *> *dimension() const {
    return GetPointer<const ::flatbuffers::Vector<const platforms::darwinn::Range *> *>(VT_DIMENSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMENSION) &&
           verifier.VerifyVector(dimension()) &&
           verifier.EndTable();
  }
};

struct TensorShapeBuilder {
  typedef TensorShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dimension(::flatbuffers::Offset<::flatbuffers::Vector<const platforms::darwinn::Range *>> dimension) {
    fbb_.AddOffset(TensorShape::VT_DIMENSION, dimension);
  }
  explicit TensorShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorShape> CreateTensorShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const platforms::darwinn::Range *>> dimension = 0) {
  TensorShapeBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorShape> CreateTensorShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<platforms::darwinn::Range> *dimension = nullptr) {
  auto dimension__ = dimension ? _fbb.CreateVectorOfStructs<platforms::darwinn::Range>(*dimension) : 0;
  return platforms::darwinn::CreateTensorShape(
      _fbb,
      dimension__);
}

struct TensorLayout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorLayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_STRIDE = 6
  };
  const platforms::darwinn::TensorShape *shape() const {
    return GetPointer<const platforms::darwinn::TensorShape *>(VT_SHAPE);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           verifier.EndTable();
  }
};

struct TensorLayoutBuilder {
  typedef TensorLayout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<platforms::darwinn::TensorShape> shape) {
    fbb_.AddOffset(TensorLayout::VT_SHAPE, shape);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(TensorLayout::VT_STRIDE, stride);
  }
  explicit TensorLayoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorLayout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorLayout> CreateTensorLayout(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0) {
  TensorLayoutBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorLayout> CreateTensorLayoutDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0,
    const std::vector<int32_t> *stride = nullptr) {
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  return platforms::darwinn::CreateTensorLayout(
      _fbb,
      shape,
      stride__);
}

struct OutputShapeInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OutputShapeInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLICE_LAYOUT = 4,
    VT_SLICE_OFFSET = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::TensorLayout>> *slice_layout() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::TensorLayout>> *>(VT_SLICE_LAYOUT);
  }
  const ::flatbuffers::Vector<int32_t> *slice_offset() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SLICE_OFFSET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SLICE_LAYOUT) &&
           verifier.VerifyVector(slice_layout()) &&
           verifier.VerifyVectorOfTables(slice_layout()) &&
           VerifyOffset(verifier, VT_SLICE_OFFSET) &&
           verifier.VerifyVector(slice_offset()) &&
           verifier.EndTable();
  }
};

struct OutputShapeInfoBuilder {
  typedef OutputShapeInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_slice_layout(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::TensorLayout>>> slice_layout) {
    fbb_.AddOffset(OutputShapeInfo::VT_SLICE_LAYOUT, slice_layout);
  }
  void add_slice_offset(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> slice_offset) {
    fbb_.AddOffset(OutputShapeInfo::VT_SLICE_OFFSET, slice_offset);
  }
  explicit OutputShapeInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OutputShapeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OutputShapeInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OutputShapeInfo> CreateOutputShapeInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::TensorLayout>>> slice_layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> slice_offset = 0) {
  OutputShapeInfoBuilder builder_(_fbb);
  builder_.add_slice_offset(slice_offset);
  builder_.add_slice_layout(slice_layout);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OutputShapeInfo> CreateOutputShapeInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<platforms::darwinn::TensorLayout>> *slice_layout = nullptr,
    const std::vector<int32_t> *slice_offset = nullptr) {
  auto slice_layout__ = slice_layout ? _fbb.CreateVector<::flatbuffers::Offset<platforms::darwinn::TensorLayout>>(*slice_layout) : 0;
  auto slice_offset__ = slice_offset ? _fbb.CreateVector<int32_t>(*slice_offset) : 0;
  return platforms::darwinn::CreateOutputShapeInfo(
      _fbb,
      slice_layout__,
      slice_offset__);
}

struct NumericsConstants FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumericsConstantsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ZERO_POINT = 4,
    VT_DEQUANTIZATION_FACTOR = 6
  };
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  float dequantization_factor() const {
    return GetField<float>(VT_DEQUANTIZATION_FACTOR, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, 4) &&
           VerifyField<float>(verifier, VT_DEQUANTIZATION_FACTOR, 4) &&
           verifier.EndTable();
  }
};

struct NumericsConstantsBuilder {
  typedef NumericsConstants Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(NumericsConstants::VT_ZERO_POINT, zero_point, 0);
  }
  void add_dequantization_factor(float dequantization_factor) {
    fbb_.AddElement<float>(NumericsConstants::VT_DEQUANTIZATION_FACTOR, dequantization_factor, 0.0f);
  }
  explicit NumericsConstantsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NumericsConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NumericsConstants>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NumericsConstants> CreateNumericsConstants(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t zero_point = 0,
    float dequantization_factor = 0.0f) {
  NumericsConstantsBuilder builder_(_fbb);
  builder_.add_dequantization_factor(dequantization_factor);
  builder_.add_zero_point(zero_point);
  return builder_.Finish();
}

struct OutputLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OutputLayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYOUT = 4,
    VT_DATA_TYPE = 6,
    VT_SHAPE_INFO = 8
  };
  const platforms::darwinn::OutputLayout *layout() const {
    return GetPointer<const platforms::darwinn::OutputLayout *>(VT_LAYOUT);
  }
  platforms::darwinn::DataType data_type() const {
    return static_cast<platforms::darwinn::DataType>(GetField<int16_t>(VT_DATA_TYPE, 0));
  }
  const platforms::darwinn::OutputShapeInfo *shape_info() const {
    return GetPointer<const platforms::darwinn::OutputShapeInfo *>(VT_SHAPE_INFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyField<int16_t>(verifier, VT_DATA_TYPE, 2) &&
           VerifyOffset(verifier, VT_SHAPE_INFO) &&
           verifier.VerifyTable(shape_info()) &&
           verifier.EndTable();
  }
};

struct OutputLayerBuilder {
  typedef OutputLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_layout(::flatbuffers::Offset<platforms::darwinn::OutputLayout> layout) {
    fbb_.AddOffset(OutputLayer::VT_LAYOUT, layout);
  }
  void add_data_type(platforms::darwinn::DataType data_type) {
    fbb_.AddElement<int16_t>(OutputLayer::VT_DATA_TYPE, static_cast<int16_t>(data_type), 0);
  }
  void add_shape_info(::flatbuffers::Offset<platforms::darwinn::OutputShapeInfo> shape_info) {
    fbb_.AddOffset(OutputLayer::VT_SHAPE_INFO, shape_info);
  }
  explicit OutputLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OutputLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OutputLayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OutputLayer> CreateOutputLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<platforms::darwinn::OutputLayout> layout = 0,
    platforms::darwinn::DataType data_type = platforms::darwinn::DataType_FIXED_POINT8,
    ::flatbuffers::Offset<platforms::darwinn::OutputShapeInfo> shape_info = 0) {
  OutputLayerBuilder builder_(_fbb);
  builder_.add_shape_info(shape_info);
  builder_.add_layout(layout);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct InputLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputLayerBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InputLayerBuilder {
  typedef InputLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit InputLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InputLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InputLayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InputLayer> CreateInputLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  InputLayerBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Layer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIZE_BYTES = 6,
    VT_Y_DIM = 8,
    VT_X_DIM = 10,
    VT_Z_DIM = 12,
    VT_NUMERICS = 14,
    VT_DATA_TYPE = 16,
    VT_ANY_LAYER_TYPE = 18,
    VT_ANY_LAYER = 20,
    VT_EXECUTION_COUNT_PER_INFERENCE = 22,
    VT_CACHE_ON_DRAM = 24,
    VT_SHAPE = 26
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t size_bytes() const {
    return GetField<int32_t>(VT_SIZE_BYTES, 0);
  }
  int32_t y_dim() const {
    return GetField<int32_t>(VT_Y_DIM, 0);
  }
  int32_t x_dim() const {
    return GetField<int32_t>(VT_X_DIM, 0);
  }
  int32_t z_dim() const {
    return GetField<int32_t>(VT_Z_DIM, 0);
  }
  const platforms::darwinn::NumericsConstants *numerics() const {
    return GetPointer<const platforms::darwinn::NumericsConstants *>(VT_NUMERICS);
  }
  platforms::darwinn::DataType data_type() const {
    return static_cast<platforms::darwinn::DataType>(GetField<int16_t>(VT_DATA_TYPE, 0));
  }
  platforms::darwinn::AnyLayer any_layer_type() const {
    return static_cast<platforms::darwinn::AnyLayer>(GetField<uint8_t>(VT_ANY_LAYER_TYPE, 0));
  }
  const void *any_layer() const {
    return GetPointer<const void *>(VT_ANY_LAYER);
  }
  template<typename T> const T *any_layer_as() const;
  const platforms::darwinn::OutputLayer *any_layer_as_OutputLayer() const {
    return any_layer_type() == platforms::darwinn::AnyLayer_OutputLayer ? static_cast<const platforms::darwinn::OutputLayer *>(any_layer()) : nullptr;
  }
  const platforms::darwinn::InputLayer *any_layer_as_InputLayer() const {
    return any_layer_type() == platforms::darwinn::AnyLayer_InputLayer ? static_cast<const platforms::darwinn::InputLayer *>(any_layer()) : nullptr;
  }
  int32_t execution_count_per_inference() const {
    return GetField<int32_t>(VT_EXECUTION_COUNT_PER_INFERENCE, 1);
  }
  bool cache_on_dram() const {
    return GetField<uint8_t>(VT_CACHE_ON_DRAM, 0) != 0;
  }
  const platforms::darwinn::TensorShape *shape() const {
    return GetPointer<const platforms::darwinn::TensorShape *>(VT_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_SIZE_BYTES, 4) &&
           VerifyField<int32_t>(verifier, VT_Y_DIM, 4) &&
           VerifyField<int32_t>(verifier, VT_X_DIM, 4) &&
           VerifyField<int32_t>(verifier, VT_Z_DIM, 4) &&
           VerifyOffset(verifier, VT_NUMERICS) &&
           verifier.VerifyTable(numerics()) &&
           VerifyField<int16_t>(verifier, VT_DATA_TYPE, 2) &&
           VerifyField<uint8_t>(verifier, VT_ANY_LAYER_TYPE, 1) &&
           VerifyOffset(verifier, VT_ANY_LAYER) &&
           VerifyAnyLayer(verifier, any_layer(), any_layer_type()) &&
           VerifyField<int32_t>(verifier, VT_EXECUTION_COUNT_PER_INFERENCE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CACHE_ON_DRAM, 1) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

template<> inline const platforms::darwinn::OutputLayer *Layer::any_layer_as<platforms::darwinn::OutputLayer>() const {
  return any_layer_as_OutputLayer();
}

template<> inline const platforms::darwinn::InputLayer *Layer::any_layer_as<platforms::darwinn::InputLayer>() const {
  return any_layer_as_InputLayer();
}

struct LayerBuilder {
  typedef Layer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Layer::VT_NAME, name);
  }
  void add_size_bytes(int32_t size_bytes) {
    fbb_.AddElement<int32_t>(Layer::VT_SIZE_BYTES, size_bytes, 0);
  }
  void add_y_dim(int32_t y_dim) {
    fbb_.AddElement<int32_t>(Layer::VT_Y_DIM, y_dim, 0);
  }
  void add_x_dim(int32_t x_dim) {
    fbb_.AddElement<int32_t>(Layer::VT_X_DIM, x_dim, 0);
  }
  void add_z_dim(int32_t z_dim) {
    fbb_.AddElement<int32_t>(Layer::VT_Z_DIM, z_dim, 0);
  }
  void add_numerics(::flatbuffers::Offset<platforms::darwinn::NumericsConstants> numerics) {
    fbb_.AddOffset(Layer::VT_NUMERICS, numerics);
  }
  void add_data_type(platforms::darwinn::DataType data_type) {
    fbb_.AddElement<int16_t>(Layer::VT_DATA_TYPE, static_cast<int16_t>(data_type), 0);
  }
  void add_any_layer_type(platforms::darwinn::AnyLayer any_layer_type) {
    fbb_.AddElement<uint8_t>(Layer::VT_ANY_LAYER_TYPE, static_cast<uint8_t>(any_layer_type), 0);
  }
  void add_any_layer(::flatbuffers::Offset<void> any_layer) {
    fbb_.AddOffset(Layer::VT_ANY_LAYER, any_layer);
  }
  void add_execution_count_per_inference(int32_t execution_count_per_inference) {
    fbb_.AddElement<int32_t>(Layer::VT_EXECUTION_COUNT_PER_INFERENCE, execution_count_per_inference, 1);
  }
  void add_cache_on_dram(bool cache_on_dram) {
    fbb_.AddElement<uint8_t>(Layer::VT_CACHE_ON_DRAM, static_cast<uint8_t>(cache_on_dram), 0);
  }
  void add_shape(::flatbuffers::Offset<platforms::darwinn::TensorShape> shape) {
    fbb_.AddOffset(Layer::VT_SHAPE, shape);
  }
  explicit LayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Layer> CreateLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t size_bytes = 0,
    int32_t y_dim = 0,
    int32_t x_dim = 0,
    int32_t z_dim = 0,
    ::flatbuffers::Offset<platforms::darwinn::NumericsConstants> numerics = 0,
    platforms::darwinn::DataType data_type = platforms::darwinn::DataType_FIXED_POINT8,
    platforms::darwinn::AnyLayer any_layer_type = platforms::darwinn::AnyLayer_NONE,
    ::flatbuffers::Offset<void> any_layer = 0,
    int32_t execution_count_per_inference = 1,
    bool cache_on_dram = false,
    ::flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0) {
  LayerBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_execution_count_per_inference(execution_count_per_inference);
  builder_.add_any_layer(any_layer);
  builder_.add_numerics(numerics);
  builder_.add_z_dim(z_dim);
  builder_.add_x_dim(x_dim);
  builder_.add_y_dim(y_dim);
  builder_.add_size_bytes(size_bytes);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  builder_.add_cache_on_dram(cache_on_dram);
  builder_.add_any_layer_type(any_layer_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Layer> CreateLayerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t size_bytes = 0,
    int32_t y_dim = 0,
    int32_t x_dim = 0,
    int32_t z_dim = 0,
    ::flatbuffers::Offset<platforms::darwinn::NumericsConstants> numerics = 0,
    platforms::darwinn::DataType data_type = platforms::darwinn::DataType_FIXED_POINT8,
    platforms::darwinn::AnyLayer any_layer_type = platforms::darwinn::AnyLayer_NONE,
    ::flatbuffers::Offset<void> any_layer = 0,
    int32_t execution_count_per_inference = 1,
    bool cache_on_dram = false,
    ::flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return platforms::darwinn::CreateLayer(
      _fbb,
      name__,
      size_bytes,
      y_dim,
      x_dim,
      z_dim,
      numerics,
      data_type,
      any_layer_type,
      any_layer,
      execution_count_per_inference,
      cache_on_dram,
      shape);
}

struct Executable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExecutableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_NAME = 6,
    VT_SERIALIZED_MODEL = 8,
    VT_BATCH_SIZE = 10,
    VT_SCRATCH_SIZE_BYTES = 12,
    VT_INSTRUCTION_BITSTREAMS = 14,
    VT_PARAMETERS = 16,
    VT_DMA_HINTS = 18,
    VT_INPUT_LAYERS = 20,
    VT_OUTPUT_LAYERS = 22,
    VT_CHIP = 24,
    VT_ESTIMATED_CYCLES = 26,
    VT_USED_NARROW_MEMORY_BYTES_PER_TILE = 28,
    VT_TYPE = 30,
    VT_PARAMETER_CACHING_TOKEN = 32,
    VT_USE_TPU_DRAM_FOR_PARAMETERS = 34,
    VT_ESTIMATED_CYCLES_64BIT = 36
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *serialized_model() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_MODEL);
  }
  int32_t batch_size() const {
    return GetField<int32_t>(VT_BATCH_SIZE, 0);
  }
  int32_t scratch_size_bytes() const {
    return GetField<int32_t>(VT_SCRATCH_SIZE_BYTES, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *instruction_bitstreams() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *>(VT_INSTRUCTION_BITSTREAMS);
  }
  const ::flatbuffers::Vector<uint8_t> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PARAMETERS);
  }
  const platforms::darwinn::DmaHints *dma_hints() const {
    return GetPointer<const platforms::darwinn::DmaHints *>(VT_DMA_HINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>> *input_layers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>> *>(VT_INPUT_LAYERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>> *output_layers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>> *>(VT_OUTPUT_LAYERS);
  }
  const ::flatbuffers::String *chip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHIP);
  }
  int32_t estimated_cycles() const {
    return GetField<int32_t>(VT_ESTIMATED_CYCLES, 0);
  }
  int32_t used_narrow_memory_bytes_per_tile() const {
    return GetField<int32_t>(VT_USED_NARROW_MEMORY_BYTES_PER_TILE, 0);
  }
  platforms::darwinn::ExecutableType type() const {
    return static_cast<platforms::darwinn::ExecutableType>(GetField<int16_t>(VT_TYPE, 0));
  }
  uint64_t parameter_caching_token() const {
    return GetField<uint64_t>(VT_PARAMETER_CACHING_TOKEN, 0);
  }
  bool use_tpu_dram_for_parameters() const {
    return GetField<uint8_t>(VT_USE_TPU_DRAM_FOR_PARAMETERS, 0) != 0;
  }
  int64_t estimated_cycles_64bit() const {
    return GetField<int64_t>(VT_ESTIMATED_CYCLES_64BIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SERIALIZED_MODEL) &&
           verifier.VerifyVector(serialized_model()) &&
           VerifyField<int32_t>(verifier, VT_BATCH_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_SCRATCH_SIZE_BYTES, 4) &&
           VerifyOffset(verifier, VT_INSTRUCTION_BITSTREAMS) &&
           verifier.VerifyVector(instruction_bitstreams()) &&
           verifier.VerifyVectorOfTables(instruction_bitstreams()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           VerifyOffset(verifier, VT_DMA_HINTS) &&
           verifier.VerifyTable(dma_hints()) &&
           VerifyOffset(verifier, VT_INPUT_LAYERS) &&
           verifier.VerifyVector(input_layers()) &&
           verifier.VerifyVectorOfTables(input_layers()) &&
           VerifyOffset(verifier, VT_OUTPUT_LAYERS) &&
           verifier.VerifyVector(output_layers()) &&
           verifier.VerifyVectorOfTables(output_layers()) &&
           VerifyOffset(verifier, VT_CHIP) &&
           verifier.VerifyString(chip()) &&
           VerifyField<int32_t>(verifier, VT_ESTIMATED_CYCLES, 4) &&
           VerifyField<int32_t>(verifier, VT_USED_NARROW_MEMORY_BYTES_PER_TILE, 4) &&
           VerifyField<int16_t>(verifier, VT_TYPE, 2) &&
           VerifyField<uint64_t>(verifier, VT_PARAMETER_CACHING_TOKEN, 8) &&
           VerifyField<uint8_t>(verifier, VT_USE_TPU_DRAM_FOR_PARAMETERS, 1) &&
           VerifyField<int64_t>(verifier, VT_ESTIMATED_CYCLES_64BIT, 8) &&
           verifier.EndTable();
  }
};

struct ExecutableBuilder {
  typedef Executable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(Executable::VT_VERSION, version, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Executable::VT_NAME, name);
  }
  void add_serialized_model(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> serialized_model) {
    fbb_.AddOffset(Executable::VT_SERIALIZED_MODEL, serialized_model);
  }
  void add_batch_size(int32_t batch_size) {
    fbb_.AddElement<int32_t>(Executable::VT_BATCH_SIZE, batch_size, 0);
  }
  void add_scratch_size_bytes(int32_t scratch_size_bytes) {
    fbb_.AddElement<int32_t>(Executable::VT_SCRATCH_SIZE_BYTES, scratch_size_bytes, 0);
  }
  void add_instruction_bitstreams(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::InstructionBitstream>>> instruction_bitstreams) {
    fbb_.AddOffset(Executable::VT_INSTRUCTION_BITSTREAMS, instruction_bitstreams);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters) {
    fbb_.AddOffset(Executable::VT_PARAMETERS, parameters);
  }
  void add_dma_hints(::flatbuffers::Offset<platforms::darwinn::DmaHints> dma_hints) {
    fbb_.AddOffset(Executable::VT_DMA_HINTS, dma_hints);
  }
  void add_input_layers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>>> input_layers) {
    fbb_.AddOffset(Executable::VT_INPUT_LAYERS, input_layers);
  }
  void add_output_layers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>>> output_layers) {
    fbb_.AddOffset(Executable::VT_OUTPUT_LAYERS, output_layers);
  }
  void add_chip(::flatbuffers::Offset<::flatbuffers::String> chip) {
    fbb_.AddOffset(Executable::VT_CHIP, chip);
  }
  void add_estimated_cycles(int32_t estimated_cycles) {
    fbb_.AddElement<int32_t>(Executable::VT_ESTIMATED_CYCLES, estimated_cycles, 0);
  }
  void add_used_narrow_memory_bytes_per_tile(int32_t used_narrow_memory_bytes_per_tile) {
    fbb_.AddElement<int32_t>(Executable::VT_USED_NARROW_MEMORY_BYTES_PER_TILE, used_narrow_memory_bytes_per_tile, 0);
  }
  void add_type(platforms::darwinn::ExecutableType type) {
    fbb_.AddElement<int16_t>(Executable::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_parameter_caching_token(uint64_t parameter_caching_token) {
    fbb_.AddElement<uint64_t>(Executable::VT_PARAMETER_CACHING_TOKEN, parameter_caching_token, 0);
  }
  void add_use_tpu_dram_for_parameters(bool use_tpu_dram_for_parameters) {
    fbb_.AddElement<uint8_t>(Executable::VT_USE_TPU_DRAM_FOR_PARAMETERS, static_cast<uint8_t>(use_tpu_dram_for_parameters), 0);
  }
  void add_estimated_cycles_64bit(int64_t estimated_cycles_64bit) {
    fbb_.AddElement<int64_t>(Executable::VT_ESTIMATED_CYCLES_64BIT, estimated_cycles_64bit, 0);
  }
  explicit ExecutableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Executable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Executable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Executable> CreateExecutable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> serialized_model = 0,
    int32_t batch_size = 0,
    int32_t scratch_size_bytes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::InstructionBitstream>>> instruction_bitstreams = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters = 0,
    ::flatbuffers::Offset<platforms::darwinn::DmaHints> dma_hints = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>>> input_layers = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::Layer>>> output_layers = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chip = 0,
    int32_t estimated_cycles = 0,
    int32_t used_narrow_memory_bytes_per_tile = 0,
    platforms::darwinn::ExecutableType type = platforms::darwinn::ExecutableType_STAND_ALONE,
    uint64_t parameter_caching_token = 0,
    bool use_tpu_dram_for_parameters = false,
    int64_t estimated_cycles_64bit = 0) {
  ExecutableBuilder builder_(_fbb);
  builder_.add_estimated_cycles_64bit(estimated_cycles_64bit);
  builder_.add_parameter_caching_token(parameter_caching_token);
  builder_.add_used_narrow_memory_bytes_per_tile(used_narrow_memory_bytes_per_tile);
  builder_.add_estimated_cycles(estimated_cycles);
  builder_.add_chip(chip);
  builder_.add_output_layers(output_layers);
  builder_.add_input_layers(input_layers);
  builder_.add_dma_hints(dma_hints);
  builder_.add_parameters(parameters);
  builder_.add_instruction_bitstreams(instruction_bitstreams);
  builder_.add_scratch_size_bytes(scratch_size_bytes);
  builder_.add_batch_size(batch_size);
  builder_.add_serialized_model(serialized_model);
  builder_.add_name(name);
  builder_.add_version(version);
  builder_.add_type(type);
  builder_.add_use_tpu_dram_for_parameters(use_tpu_dram_for_parameters);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Executable> CreateExecutableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *serialized_model = nullptr,
    int32_t batch_size = 0,
    int32_t scratch_size_bytes = 0,
    const std::vector<::flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *instruction_bitstreams = nullptr,
    const std::vector<uint8_t> *parameters = nullptr,
    ::flatbuffers::Offset<platforms::darwinn::DmaHints> dma_hints = 0,
    const std::vector<::flatbuffers::Offset<platforms::darwinn::Layer>> *input_layers = nullptr,
    const std::vector<::flatbuffers::Offset<platforms::darwinn::Layer>> *output_layers = nullptr,
    const char *chip = nullptr,
    int32_t estimated_cycles = 0,
    int32_t used_narrow_memory_bytes_per_tile = 0,
    platforms::darwinn::ExecutableType type = platforms::darwinn::ExecutableType_STAND_ALONE,
    uint64_t parameter_caching_token = 0,
    bool use_tpu_dram_for_parameters = false,
    int64_t estimated_cycles_64bit = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto serialized_model__ = serialized_model ? _fbb.CreateVector<uint8_t>(*serialized_model) : 0;
  auto instruction_bitstreams__ = instruction_bitstreams ? _fbb.CreateVector<::flatbuffers::Offset<platforms::darwinn::InstructionBitstream>>(*instruction_bitstreams) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<uint8_t>(*parameters) : 0;
  auto input_layers__ = input_layers ? _fbb.CreateVector<::flatbuffers::Offset<platforms::darwinn::Layer>>(*input_layers) : 0;
  auto output_layers__ = output_layers ? _fbb.CreateVector<::flatbuffers::Offset<platforms::darwinn::Layer>>(*output_layers) : 0;
  auto chip__ = chip ? _fbb.CreateString(chip) : 0;
  return platforms::darwinn::CreateExecutable(
      _fbb,
      version,
      name__,
      serialized_model__,
      batch_size,
      scratch_size_bytes,
      instruction_bitstreams__,
      parameters__,
      dma_hints,
      input_layers__,
      output_layers__,
      chip__,
      estimated_cycles,
      used_narrow_memory_bytes_per_tile,
      type,
      parameter_caching_token,
      use_tpu_dram_for_parameters,
      estimated_cycles_64bit);
}

struct MultiExecutable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiExecutableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIALIZED_EXECUTABLES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *serialized_executables() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SERIALIZED_EXECUTABLES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERIALIZED_EXECUTABLES) &&
           verifier.VerifyVector(serialized_executables()) &&
           verifier.VerifyVectorOfStrings(serialized_executables()) &&
           verifier.EndTable();
  }
};

struct MultiExecutableBuilder {
  typedef MultiExecutable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_serialized_executables(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> serialized_executables) {
    fbb_.AddOffset(MultiExecutable::VT_SERIALIZED_EXECUTABLES, serialized_executables);
  }
  explicit MultiExecutableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MultiExecutable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MultiExecutable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MultiExecutable> CreateMultiExecutable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> serialized_executables = 0) {
  MultiExecutableBuilder builder_(_fbb);
  builder_.add_serialized_executables(serialized_executables);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MultiExecutable> CreateMultiExecutableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *serialized_executables = nullptr) {
  auto serialized_executables__ = serialized_executables ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*serialized_executables) : 0;
  return platforms::darwinn::CreateMultiExecutable(
      _fbb,
      serialized_executables__);
}

struct SerializedPackage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SerializedPackageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIALIZED_PACKAGE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *serialized_package() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_PACKAGE);
  }
  const platforms::darwinn::Package *serialized_package_nested_root() const {
    const auto _f = serialized_package();
    return _f ? ::flatbuffers::GetRoot<platforms::darwinn::Package>(_f->Data())
              : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERIALIZED_PACKAGE) &&
           verifier.VerifyVector(serialized_package()) &&
           verifier.VerifyNestedFlatBuffer<platforms::darwinn::Package>(serialized_package(), nullptr) &&
           verifier.EndTable();
  }
};

struct SerializedPackageBuilder {
  typedef SerializedPackage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_serialized_package(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> serialized_package) {
    fbb_.AddOffset(SerializedPackage::VT_SERIALIZED_PACKAGE, serialized_package);
  }
  explicit SerializedPackageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SerializedPackage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SerializedPackage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SerializedPackage> CreateSerializedPackage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> serialized_package = 0) {
  SerializedPackageBuilder builder_(_fbb);
  builder_.add_serialized_package(serialized_package);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SerializedPackage> CreateSerializedPackageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *serialized_package = nullptr) {
  auto serialized_package__ = serialized_package ? _fbb.CreateVector<uint8_t>(*serialized_package) : 0;
  return platforms::darwinn::CreateSerializedPackage(
      _fbb,
      serialized_package__);
}

struct Package FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PackageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_RUNTIME_VERSION = 4,
    VT_SERIALIZED_MULTI_EXECUTABLE = 6,
    VT_SIGNATURE = 8,
    VT_KEYPAIR_VERSION = 10,
    VT_COMPILER_VERSION = 12,
    VT_VIRTUAL_CHIP_ID = 14,
    VT_MULTI_CHIP_PACKAGE = 16,
    VT_MODEL_IDENTIFIER = 18
  };
  int32_t min_runtime_version() const {
    return GetField<int32_t>(VT_MIN_RUNTIME_VERSION, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *serialized_multi_executable() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_MULTI_EXECUTABLE);
  }
  const ::flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  int32_t keypair_version() const {
    return GetField<int32_t>(VT_KEYPAIR_VERSION, 0);
  }
  const ::flatbuffers::String *compiler_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMPILER_VERSION);
  }
  int32_t virtual_chip_id() const {
    return GetField<int32_t>(VT_VIRTUAL_CHIP_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *multi_chip_package() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *>(VT_MULTI_CHIP_PACKAGE);
  }
  const ::flatbuffers::String *model_identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_IDENTIFIER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN_RUNTIME_VERSION, 4) &&
           VerifyOffset(verifier, VT_SERIALIZED_MULTI_EXECUTABLE) &&
           verifier.VerifyVector(serialized_multi_executable()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyField<int32_t>(verifier, VT_KEYPAIR_VERSION, 4) &&
           VerifyOffset(verifier, VT_COMPILER_VERSION) &&
           verifier.VerifyString(compiler_version()) &&
           VerifyField<int32_t>(verifier, VT_VIRTUAL_CHIP_ID, 4) &&
           VerifyOffset(verifier, VT_MULTI_CHIP_PACKAGE) &&
           verifier.VerifyVector(multi_chip_package()) &&
           verifier.VerifyVectorOfTables(multi_chip_package()) &&
           VerifyOffset(verifier, VT_MODEL_IDENTIFIER) &&
           verifier.VerifyString(model_identifier()) &&
           verifier.EndTable();
  }
};

struct PackageBuilder {
  typedef Package Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min_runtime_version(int32_t min_runtime_version) {
    fbb_.AddElement<int32_t>(Package::VT_MIN_RUNTIME_VERSION, min_runtime_version, 0);
  }
  void add_serialized_multi_executable(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> serialized_multi_executable) {
    fbb_.AddOffset(Package::VT_SERIALIZED_MULTI_EXECUTABLE, serialized_multi_executable);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(Package::VT_SIGNATURE, signature);
  }
  void add_keypair_version(int32_t keypair_version) {
    fbb_.AddElement<int32_t>(Package::VT_KEYPAIR_VERSION, keypair_version, 0);
  }
  void add_compiler_version(::flatbuffers::Offset<::flatbuffers::String> compiler_version) {
    fbb_.AddOffset(Package::VT_COMPILER_VERSION, compiler_version);
  }
  void add_virtual_chip_id(int32_t virtual_chip_id) {
    fbb_.AddElement<int32_t>(Package::VT_VIRTUAL_CHIP_ID, virtual_chip_id, 0);
  }
  void add_multi_chip_package(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::SerializedPackage>>> multi_chip_package) {
    fbb_.AddOffset(Package::VT_MULTI_CHIP_PACKAGE, multi_chip_package);
  }
  void add_model_identifier(::flatbuffers::Offset<::flatbuffers::String> model_identifier) {
    fbb_.AddOffset(Package::VT_MODEL_IDENTIFIER, model_identifier);
  }
  explicit PackageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Package> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Package>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Package> CreatePackage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_runtime_version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> serialized_multi_executable = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> signature = 0,
    int32_t keypair_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> compiler_version = 0,
    int32_t virtual_chip_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<platforms::darwinn::SerializedPackage>>> multi_chip_package = 0,
    ::flatbuffers::Offset<::flatbuffers::String> model_identifier = 0) {
  PackageBuilder builder_(_fbb);
  builder_.add_model_identifier(model_identifier);
  builder_.add_multi_chip_package(multi_chip_package);
  builder_.add_virtual_chip_id(virtual_chip_id);
  builder_.add_compiler_version(compiler_version);
  builder_.add_keypair_version(keypair_version);
  builder_.add_signature(signature);
  builder_.add_serialized_multi_executable(serialized_multi_executable);
  builder_.add_min_runtime_version(min_runtime_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Package> CreatePackageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_runtime_version = 0,
    const std::vector<uint8_t> *serialized_multi_executable = nullptr,
    const std::vector<uint8_t> *signature = nullptr,
    int32_t keypair_version = 0,
    const char *compiler_version = nullptr,
    int32_t virtual_chip_id = 0,
    const std::vector<::flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *multi_chip_package = nullptr,
    const char *model_identifier = nullptr) {
  auto serialized_multi_executable__ = serialized_multi_executable ? _fbb.CreateVector<uint8_t>(*serialized_multi_executable) : 0;
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto compiler_version__ = compiler_version ? _fbb.CreateString(compiler_version) : 0;
  auto multi_chip_package__ = multi_chip_package ? _fbb.CreateVector<::flatbuffers::Offset<platforms::darwinn::SerializedPackage>>(*multi_chip_package) : 0;
  auto model_identifier__ = model_identifier ? _fbb.CreateString(model_identifier) : 0;
  return platforms::darwinn::CreatePackage(
      _fbb,
      min_runtime_version,
      serialized_multi_executable__,
      signature__,
      keypair_version,
      compiler_version__,
      virtual_chip_id,
      multi_chip_package__,
      model_identifier__);
}

inline bool VerifyAnyHint(::flatbuffers::Verifier &verifier, const void *obj, AnyHint type) {
  switch (type) {
    case AnyHint_NONE: {
      return true;
    }
    case AnyHint_DmaDescriptorHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::DmaDescriptorHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyHint_InstructionHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InstructionHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyHint_InterruptHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InterruptHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyHint_FenceHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::FenceHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyHintVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyHint(
        verifier,  values->Get(i), types->GetEnum<AnyHint>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyLayer(::flatbuffers::Verifier &verifier, const void *obj, AnyLayer type) {
  switch (type) {
    case AnyLayer_NONE: {
      return true;
    }
    case AnyLayer_OutputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::OutputLayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyLayer_InputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InputLayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyLayerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyLayer(
        verifier,  values->Get(i), types->GetEnum<AnyLayer>(i))) {
      return false;
    }
  }
  return true;
}

inline const platforms::darwinn::Package *GetPackage(const void *buf) {
  return ::flatbuffers::GetRoot<platforms::darwinn::Package>(buf);
}

inline const platforms::darwinn::Package *GetSizePrefixedPackage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<platforms::darwinn::Package>(buf);
}

inline const char *PackageIdentifier() {
  return "DWN1";
}

inline bool PackageBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PackageIdentifier());
}

inline bool SizePrefixedPackageBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PackageIdentifier(), true);
}

inline bool VerifyPackageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<platforms::darwinn::Package>(PackageIdentifier());
}

inline bool VerifySizePrefixedPackageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<platforms::darwinn::Package>(PackageIdentifier());
}

inline void FinishPackageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<platforms::darwinn::Package> root) {
  fbb.Finish(root, PackageIdentifier());
}

inline void FinishSizePrefixedPackageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<platforms::darwinn::Package> root) {
  fbb.FinishSizePrefixed(root, PackageIdentifier());
}

}  // namespace darwinn
}  // namespace platforms

#endif  // FLATBUFFERS_GENERATED_EXECUTABLE_PLATFORMS_DARWINN_H_
